import {
  Input_default
} from "./chunk-LEMKDM4U.js";
import {
  Button_default,
  COLORPICKER_ALPHA,
  COLORPICKER_ALPHA_SLIDER,
  COLORPICKER_BLUE,
  COLORPICKER_GREEN,
  COLORPICKER_HEX,
  COLORPICKER_HUE,
  COLORPICKER_HUE_SLIDER,
  COLORPICKER_LIGHT,
  COLORPICKER_RED,
  COLORPICKER_SATURATION,
  COLORPICKER_TOGGLE_MODE_TOOLTIP,
  Fragment,
  Icon_default,
  JsxRenderer_default,
  Label_default,
  ResizeHandler_default,
  SLIDER_ARIA_DESCRIPTION,
  SLIDER_TOOLTIP_INPUT_DESCRIPTION,
  SLIDER_TOOLTIP_INPUT_LABEL,
  UI5Element_default,
  customElement_default,
  event_strict_default,
  i18n_default,
  isDown,
  isDownCtrl,
  isEnd,
  isEnter,
  isEscape,
  isF2,
  isHome,
  isLeft,
  isLeftCtrl,
  isMinus,
  isPageDown,
  isPageUp,
  isPlus,
  isRight,
  isRightCtrl,
  isUp,
  isUpCtrl,
  jsx,
  jsxs,
  parameters_bundle_css_default,
  parameters_bundle_css_default2,
  property_default
} from "./chunk-ANJ7DKRT.js";
import {
  ICON_EXPAND
} from "./chunk-7MCSUB2E.js";
import {
  registerIcon
} from "./chunk-Y4O442SL.js";
import {
  getScopedVarName,
  isPhone,
  registerThemePropertiesLoader,
  supportsTouch
} from "./chunk-NPG2NGWT.js";

// node_modules/@ui5/webcomponents-base/dist/util/ColorConversion.js
var CSSColors = /* @__PURE__ */ new Map([
  ["aliceblue", "f0f8ff"],
  ["antiquewhite", "faebd7"],
  ["aqua", "00ffff"],
  ["aquamarine", "7fffd4"],
  ["azure", "f0ffff"],
  ["beige", "f5f5dc"],
  ["bisque", "ffe4c4"],
  ["black", "000000"],
  ["blanchedalmond", "ffebcd"],
  ["blue", "0000ff"],
  ["blueviolet", "8a2be2"],
  ["brown", "a52a2a"],
  ["burlywood", "deb887"],
  ["cadetblue", "5f9ea0"],
  ["chartreuse", "7fff00"],
  ["chocolate", "d2691e"],
  ["coral", "ff7f50"],
  ["cornflowerblue", "6495ed"],
  ["cornsilk", "fff8dc"],
  ["crimson", "dc143c"],
  ["cyan", "00ffff"],
  ["darkblue", "00008b"],
  ["darkcyan", "008b8b"],
  ["darkgoldenrod", "b8860b"],
  ["darkgray", "a9a9a9"],
  ["darkgrey", "a9a9a9"],
  ["darkgreen", "006400"],
  ["darkkhaki", "bdb76b"],
  ["darkmagenta", "8b008b"],
  ["darkolivegreen", "556b2f"],
  ["darkorange", "ff8c00"],
  ["darkorchid", "9932cc"],
  ["darkred", "8b0000"],
  ["darksalmon", "e9967a"],
  ["darkseagreen", "8fbc8f"],
  ["darkslateblue", "483d8b"],
  ["darkslategray", "2f4f4f"],
  ["darkslategrey", "2f4f4f"],
  ["darkturquoise", "00ced1"],
  ["darkviolet", "9400d3"],
  ["deeppink", "ff1493"],
  ["deepskyblue", "00bfff"],
  ["dimgray", "696969"],
  ["dimgrey", "696969"],
  ["dodgerblue", "1e90ff"],
  ["firebrick", "b22222"],
  ["floralwhite", "fffaf0"],
  ["forestgreen", "228b22"],
  ["fuchsia", "ff00ff"],
  ["gainsboro", "dcdcdc"],
  ["ghostwhite", "f8f8ff"],
  ["gold", "ffd700"],
  ["goldenrod", "daa520"],
  ["gray", "808080"],
  ["grey", "808080"],
  ["green", "008000"],
  ["greenyellow", "adff2f"],
  ["honeydew", "f0fff0"],
  ["hotpink", "ff69b4"],
  ["indianred", "cd5c5c"],
  ["indigo", "4b0082"],
  ["ivory", "fffff0"],
  ["khaki", "f0e68c"],
  ["lavender", "e6e6fa"],
  ["lavenderblush", "fff0f5"],
  ["lawngreen", "7cfc00"],
  ["lemonchiffon", "fffacd"],
  ["lightblue", "add8e6"],
  ["lightcoral", "f08080"],
  ["lightcyan", "e0ffff"],
  ["lightgoldenrodyellow", "fafad2"],
  ["lightgray", "d3d3d3"],
  ["lightgrey", "d3d3d3"],
  ["lightgreen", "90ee90"],
  ["lightpink", "ffb6c1"],
  ["lightsalmon", "ffa07a"],
  ["lightseagreen", "20b2aa"],
  ["lightskyblue", "87cefa"],
  ["lightslategray", "778899"],
  ["lightslategrey", "778899"],
  ["lightsteelblue", "b0c4de"],
  ["lightyellow", "ffffe0"],
  ["lime", "00ff00"],
  ["limegreen", "32cd32"],
  ["linen", "faf0e6"],
  ["magenta", "ff00ff"],
  ["maroon", "800000"],
  ["mediumaquamarine", "66cdaa"],
  ["mediumblue", "0000cd"],
  ["mediumorchid", "ba55d3"],
  ["mediumpurple", "9370db"],
  ["mediumseagreen", "3cb371"],
  ["mediumslateblue", "7b68ee"],
  ["mediumspringgreen", "00fa9a"],
  ["mediumturquoise", "48d1cc"],
  ["mediumvioletred", "c71585"],
  ["midnightblue", "191970"],
  ["mintcream", "f5fffa"],
  ["mistyrose", "ffe4e1"],
  ["moccasin", "ffe4b5"],
  ["navajowhite", "ffdead"],
  ["navy", "000080"],
  ["oldlace", "fdf5e6"],
  ["olive", "808000"],
  ["olivedrab", "6b8e23"],
  ["orange", "ffa500"],
  ["orangered", "ff4500"],
  ["orchid", "da70d6"],
  ["palegoldenrod", "eee8aa"],
  ["palegreen", "98fb98"],
  ["paleturquoise", "afeeee"],
  ["palevioletred", "db7093"],
  ["papayawhip", "ffefd5"],
  ["peachpuff", "ffdab9"],
  ["peru", "cd853f"],
  ["pink", "ffc0cb"],
  ["plum", "dda0dd"],
  ["powderblue", "b0e0e6"],
  ["purple", "800080"],
  ["red", "ff0000"],
  ["rosybrown", "bc8f8f"],
  ["royalblue", "4169e1"],
  ["saddlebrown", "8b4513"],
  ["salmon", "fa8072"],
  ["sandybrown", "f4a460"],
  ["seagreen", "2e8b57"],
  ["seashell", "fff5ee"],
  ["sienna", "a0522d"],
  ["silver", "c0c0c0"],
  ["skyblue", "87ceeb"],
  ["slateblue", "6a5acd"],
  ["slategray", "708090"],
  ["slategrey", "708090"],
  ["snow", "fffafa"],
  ["springgreen", "00ff7f"],
  ["steelblue", "4682b4"],
  ["tan", "d2b48c"],
  ["teal", "008080"],
  ["thistle", "d8bfd8"],
  ["tomato", "ff6347"],
  ["turquoise", "40e0d0"],
  ["violet", "ee82ee"],
  ["wheat", "f5deb3"],
  ["white", "ffffff"],
  ["whitesmoke", "f5f5f5"],
  ["yellow", "ffff00"],
  ["yellowgreen", "9acd32"],
  ["transparent", "00000000"]
]);
var getRGBColor = (color) => {
  if (color.startsWith("rgba")) {
    return RGBAToRGB(color);
  }
  if (color.startsWith("rgb")) {
    return RGBStringToRGBObject(color);
  }
  if (color.indexOf("#") === 0) {
    if (color.length === 4) {
      color = `${color[1]}${color[1]}${color[2]}${color[2]}${color[3]}${color[3]}`;
    } else {
      color = color.slice(1, color.length);
    }
  }
  if (CSSColors.has(color)) {
    color = CSSColors.get(color);
  }
  return HEXToRGB(color);
};
var getAlpha = (color) => {
  let alpha = 1;
  if (color.startsWith("rgba") || color.startsWith("hsla")) {
    const parts = color.split(",");
    if (parts.length === 4) {
      alpha = parseFloat(parts[3].replace(")", "").trim());
    }
  }
  return alpha;
};
var RGBAToRGB = (color) => {
  const openingBracketIndex = color.indexOf("("), commasIndexes = [];
  for (let i = 0; i < color.length; i++) {
    if (color[i] === ",") {
      commasIndexes.push(i);
    }
  }
  return {
    r: parseInt(color.slice(openingBracketIndex + 1, commasIndexes[0]).trim()),
    g: parseInt(color.slice(commasIndexes[0] + 1, commasIndexes[1]).trim()),
    b: parseInt(color.slice(commasIndexes[1] + 1, commasIndexes[2]).trim())
  };
};
var RGBStringToRGBObject = (color) => {
  const openingBracketIndex = color.indexOf("("), closingBraketIndex = color.indexOf(")"), commasIndexes = [];
  for (let i = 0; i < color.length; i++) {
    if (color[i] === ",") {
      commasIndexes.push(i);
    }
  }
  return {
    r: parseInt(color.slice(openingBracketIndex + 1, commasIndexes[0]).trim()),
    g: parseInt(color.slice(commasIndexes[0] + 1, commasIndexes[1]).trim()),
    b: parseInt(color.slice(commasIndexes[1] + 1, closingBraketIndex).trim())
  };
};
var HSLToRGB = (color) => {
  let saturation = color.s, lightness = color.l, red, green, blue;
  if (saturation > 100) {
    saturation = 1;
  } else if (saturation < 0) {
    saturation = 0;
  } else {
    saturation /= 100;
  }
  if (lightness > 100) {
    lightness = 1;
  } else if (lightness < 0) {
    lightness = 0;
  } else {
    lightness /= 100;
  }
  const hue = (color.h % 360 + 360) % 360, d = saturation * (1 - Math.abs(2 * lightness - 1)), m = 255 * (lightness - 0.5 * d), x = d * (1 - Math.abs(hue / 60 % 2 - 1)), i = Math.floor(hue / 60), m255x = m + 255 * x, m255d = m + 255 * d;
  switch (i) {
    case 0:
      red = m255d;
      green = m255x;
      blue = m;
      break;
    case 1:
      red = m255x;
      green = m255d;
      blue = m;
      break;
    case 2:
      red = m;
      green = m255d;
      blue = m255x;
      break;
    case 3:
      red = m;
      green = m255x;
      blue = m255d;
      break;
    case 4:
      red = m255x;
      green = m;
      blue = m255d;
      break;
    case 5:
      red = m255d;
      green = m;
      blue = m255x;
      break;
    default:
      red = 0;
      green = 0;
      blue = 0;
      break;
  }
  return {
    r: Math.round(red),
    g: Math.round(green),
    b: Math.round(blue)
  };
};
var HEXToRGB = (hex) => {
  return {
    r: parseInt(hex.substr(0, 2), 16),
    g: parseInt(hex.substr(2, 2), 16),
    b: parseInt(hex.substr(4, 2), 16)
  };
};
var RGBtoHEX = (color) => {
  const hexMap = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
  let hexValue = "";
  let divisionNumber = color.r / 16;
  let remainder = color.r % 16;
  hexValue += String(hexMap[Math.floor(divisionNumber)]);
  hexValue += String(hexMap[remainder]);
  divisionNumber = color.g / 16;
  remainder = color.g % 16;
  hexValue += String(hexMap[Math.floor(divisionNumber)]);
  hexValue += String(hexMap[remainder]);
  divisionNumber = color.b / 16;
  remainder = color.b % 16;
  hexValue += String(hexMap[Math.floor(divisionNumber)]);
  hexValue += String(hexMap[remainder]);
  return hexValue;
};
var RGBToHSL = (color) => {
  const R = color.r / 255, G = color.g / 255, B = color.b / 255, max = Math.max(R, G, B), min = Math.min(R, G, B), delta = max - min;
  let h = (max + min) / 2;
  let s = (max + min) / 2;
  let l = (max + min) / 2;
  if (max === min) {
    h = 0;
    s = 0;
  } else {
    s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);
    switch (max) {
      case R:
        h = (G - B) / delta + (G < B ? 6 : 0);
        break;
      case G:
        h = (B - R) / delta + 2;
        break;
      case B:
        h = (R - G) / delta + 4;
        break;
    }
    h /= 6;
  }
  h = Math.round(h * 360);
  s = Math.round(s * 100);
  l = Math.round(l * 100);
  return {
    h,
    s,
    l
  };
};

// node_modules/@ui5/webcomponents-icons/dist/v4/expand.js
var name = "expand";
var pathData = "M80 320v128h384V64H208V32h256q13 0 22.5 9t9.5 23v384q0 13-9.5 22.5T464 480H80q-14 0-23-9.5T48 448V320h32zm176-80V128h32v112h112v32H288v112h-32V272H144v-32h112zM22 227l87-95q6-5 0-11L23 28Q11 17 23 5q5-5 11-5t11 5l92 99q9 10 9 23t-9 22L45 250q-5 5-11 5-4 0-12-5-12-12 0-23z";
var ltr = false;
var accData = ICON_EXPAND;
var collection = "SAP-icons-v4";
var packageName = "@ui5/webcomponents-icons";
registerIcon(name, { pathData, ltr, accData, collection, packageName });

// node_modules/@ui5/webcomponents-icons/dist/v5/expand.js
var name2 = "expand";
var pathData2 = "M256 32q11 0 19 8l134 141q7 7 7 17 0 11-7.5 18.5T390 224q-10 0-18-8L256 95 140 216q-8 8-18 8-11 0-18.5-7.5T96 198q0-10 7-17L238 40q6-8 18-8zm134 256q11 0 18.5 7.5T416 314q0 10-7 17L275 472q-8 8-19 8-12 0-18-8L103 331q-7-7-7-17 0-11 7.5-18.5T122 288q10 0 18 8l116 121 116-121q8-8 18-8z";
var ltr2 = false;
var accData2 = ICON_EXPAND;
var collection2 = "SAP-icons-v5";
var packageName2 = "@ui5/webcomponents-icons";
registerIcon(name2, { pathData: pathData2, ltr: ltr2, accData: accData2, collection: collection2, packageName: packageName2 });

// node_modules/@ui5/webcomponents/dist/colorpicker-utils/ColorValue.js
var ColorValue = class {
  constructor() {
    this._rgb = { r: 255, g: 255, b: 255 };
    this._hsl = RGBToHSL(this._rgb);
    this._hex = RGBtoHEX(this._rgb);
    this._alpha = 1;
    this._valid = true;
  }
  get RGB() {
    return this._rgb;
  }
  get HSL() {
    return this._hsl;
  }
  get H() {
    return this._hsl.h;
  }
  get S() {
    return this._hsl.s;
  }
  get L() {
    return this._hsl.l;
  }
  get R() {
    return this._rgb.r;
  }
  get G() {
    return this._rgb.g;
  }
  get B() {
    return this._rgb.b;
  }
  get Alpha() {
    return this._alpha;
  }
  get HEX() {
    return this._hex;
  }
  set RGB(color) {
    this.validateRGBColor(color);
    this._updateRGB(color);
  }
  set HSL(color) {
    this.validateHSLColor(color);
    this._updateHSL(color);
  }
  set HEX(value) {
    this._hex = value;
    this.validateHEX(value);
    if (this._valid) {
      this._rgb = HEXToRGB(value);
      this._hsl = RGBToHSL(this._rgb);
    }
  }
  set H(value) {
    this.validateHValue(value);
    this._updateHSL({ h: value, s: this.S, l: this.L });
  }
  set S(value) {
    this.validateSLValue(value);
    this._updateHSL({ h: this.H, s: value, l: this.L });
  }
  set L(value) {
    this.validateSLValue(value);
    this._updateHSL({ h: this.H, s: this.S, l: value });
  }
  set R(value) {
    this.validateRGBValue(value);
    this._updateRGB({ r: value, g: this.G, b: this.B });
  }
  set G(value) {
    this.validateRGBValue(value);
    this._updateRGB(this.RGB = { r: this.R, g: value, b: this.B });
  }
  set B(value) {
    this.validateRGBValue(value);
    this._updateRGB({ r: this.R, g: this.G, b: value });
  }
  set Alpha(value) {
    this._alpha = value;
  }
  isColorValueValid() {
    return this._valid;
  }
  validateRGBValue(value) {
    this._valid = this._isValidRGBValue(value);
  }
  validateRGBColor(color) {
    this._valid = this._isValidRGBValue(color.r) && this._isValidRGBValue(color.g) && this._isValidRGBValue(color.b);
  }
  validateHSLColor(color) {
    this._valid = this._isValidHValue(color.h) && this._isValidSLValue(color.s) && this._isValidSLValue(color.l);
  }
  validateHValue(value) {
    this._valid = this._isValidHValue(value);
  }
  validateSLValue(value) {
    this._valid = this._isValidSLValue(value);
  }
  validateHEX(value) {
    const hexRegex = new RegExp("^[<0-9 abcdef]+$");
    this._valid = value.length === 6 && hexRegex.test(value);
  }
  _isValidRGBValue(value) {
    return value >= 0 && value <= 255;
  }
  _isValidHValue(value) {
    return value >= 0 && value <= 360;
  }
  _isValidSLValue(value) {
    return value >= 0 && value <= 100;
  }
  _updateRGB(value) {
    this._rgb = value;
    if (this._valid) {
      this._hsl = RGBToHSL(value);
      this._hex = RGBtoHEX(value);
    }
  }
  _updateHSL(value) {
    this._hsl = value;
    if (this._valid) {
      this._rgb = HSLToRGB(value);
      this._hex = RGBtoHEX(this._rgb);
    }
  }
  toRGBString() {
    return `rgba(${this._rgb.r}, ${this._rgb.g}, ${this._rgb.b}, ${this._alpha})`;
  }
};
var ColorValue_default = ColorValue;

// node_modules/@ui5/webcomponents/dist/generated/themes/SliderBase.css.js
registerThemePropertiesLoader("@ui5/webcomponents-theming", "sap_horizon", async () => parameters_bundle_css_default);
registerThemePropertiesLoader("@ui5/webcomponents", "sap_horizon", async () => parameters_bundle_css_default2);
var SliderBase_css_default = `.ui5-hidden-text{position:absolute;clip:rect(1px,1px,1px,1px);user-select:none;left:-1000px;top:-1000px;pointer-events:none;font-size:0}:host([disabled]){opacity:var(--_ui5-v2-8-0_slider_disabled_opacity);cursor:default;pointer-events:none}:host{box-sizing:border-box;cursor:pointer;vertical-align:top;width:100%}:host(:not([hidden])){display:inline-block}.ui5-slider-root{box-sizing:border-box;height:3.3125rem;outline:none;padding:var(--_ui5-v2-8-0_slider_padding);touch-action:none}.ui5-slider-inner{background-repeat:no-repeat;position:relative;min-width:var(--_ui5-v2-8-0_slider_inner_min_width);height:100%}.ui5-slider-progress-container{width:100%;background:var(--_ui5-v2-8-0_slider_progress_container_background);border:var(--_ui5-v2-8-0_slider_progress_border);border-radius:var(--_ui5-v2-8-0_slider_progress_border_radius);height:var(--_ui5-v2-8-0_slider_inner_height);position:relative;box-sizing:var(--_ui5-v2-8-0_slider_progress_box_sizing);top:var(--_ui5-v2-8-0_slider_progress_container_top)}.ui5-slider-progress-container:before,.ui5-slider-progress-container:after{display:var(--_ui5-v2-8-0_slider_progress_container_dot_display);content:"";position:absolute;border-radius:50%;width:var(--_ui5-v2-8-0_slider_start_end_point_size);height:var(--_ui5-v2-8-0_slider_start_end_point_size);top:var(--_ui5-v2-8-0_slider_start_end_point_top)}.ui5-slider-progress-container:before{inset-inline-start:var(--_ui5-v2-8-0_slider_start_end_point_left);background-color:var(--_ui5-v2-8-0_slider_progress_before_background);border:var(--_ui5-v2-8-0_slider_progress_before_border)}.ui5-slider-progress-container:after{inset-inline-end:var(--_ui5-v2-8-0_slider_start_end_point_left);background-color:var(--_ui5-v2-8-0_slider_progress_after_background);border:var(--_ui5-v2-8-0_slider_progress_after_border)}.ui5-slider-progress{background:var(--_ui5-v2-8-0_slider_progress_background);border-radius:var(--_ui5-v2-8-0_slider_progress_border_radius);height:var(--_ui5-v2-8-0_slider_progress_height);position:relative;outline:none;box-sizing:border-box;border:var(--_ui5-v2-8-0_slider_active_progress_border);left:var(--_ui5-v2-8-0_slider_active_progress_left);top:var(--_ui5-v2-8-0_slider_active_progress_top)}.ui5-slider-tickmarks{list-style:none;padding:0;margin:0;top:var(--_ui5-v2-8-0_slider_tickmark_top);display:flex;box-sizing:border-box;width:100%;justify-content:space-between;position:absolute;z-index:1}.ui5-slider-tickmarks li{height:var(--_ui5-v2-8-0_slider_tickmark_height);border-inline-start:1px solid var(--_ui5-v2-8-0_slider_tickmark_bg)}.ui5-slider-handle{background:var(--_ui5-v2-8-0_slider_handle_background);border:var(--_ui5-v2-8-0_slider_handle_border);border-radius:var(--_ui5-v2-8-0_slider_handle_border_radius);position:relative;outline:none;height:var(--_ui5-v2-8-0_slider_handle_height);width:var(--_ui5-v2-8-0_slider_handle_width);box-sizing:var(--_ui5-v2-8-0_slider_handle_box_sizing);display:flex;justify-content:center;align-items:center;z-index:2}[slider-icon]{display:var(--_ui5-v2-8-0_slider_handle_icon_display);color:var(--sapContent_Selected_ForegroundColor);width:var(--_ui5-v2-8-0_slider_handle_icon_size);height:var(--_ui5-v2-8-0_slider_handle_icon_size)}.ui5-slider-root .ui5-slider-handle:focus [slider-icon]{display:var(--_ui5-v2-8-0_range_slider_active_handle_icon_display)}.ui5-slider-progress-container:hover~.ui5-slider-handle:not(:focus),.ui5-slider-handle:hover{background:var(--_ui5-v2-8-0_slider_handle_hover_background);border:var(--_ui5-v2-8-0_slider_handle_hover_border)}.ui5-slider-root:focus .ui5-slider-inner .ui5-slider-handle,.ui5-slider-handle:focus{outline:var(--_ui5-v2-8-0_slider_handle_outline);outline-offset:var(--_ui5-v2-8-0_slider_handle_outline_offset);border:var(--_ui5-v2-8-0_slider_handle_focus_border);background:var(--_ui5-v2-8-0_slider_handle_background_focus)}.ui5-slider-handle.ui5-slider-handle--start:focus,.ui5-slider-handle--end:focus{border:var(--_ui5-v2-8-0_slider_handle_focus_border)}.ui5-slider-root:focus:hover .ui5-slider-handle,.ui5-slider-handle:focus:hover{border:var(--_ui5-v2-8-0_slider_handle_focus_border)}.ui5-slider-handle-container{position:absolute;margin-inline-start:calc(-1 * var(--_ui5-v2-8-0_slider_handle_width) / 2);top:var(--_ui5-v2-8-0_slider_handle_top)}:host(:not([hidden])) .ui5-slider-handle-container .ui5-slider-tooltip{display:flex;font-family:var(--sapFontFamily);justify-content:center;align-items:center;visibility:hidden;position:absolute;left:50%;transform:translate(-50%);bottom:var(--_ui5-v2-8-0_slider_tooltip_bottom);background:var(--_ui5-v2-8-0_slider_tooltip_background);border:var(--_ui5-v2-8-0_slider_tooltip_border);border-radius:var(--_ui5-v2-8-0_slider_tooltip_border_radius);box-shadow:var(--_ui5-v2-8-0_slider_tooltip_box_shadow);font-size:var(--_ui5-v2-8-0_slider_tooltip_fontsize);color:var(--_ui5-v2-8-0_slider_tooltip_color);height:var(--_ui5-v2-8-0_slider_tooltip_height);min-width:var(--_ui5-v2-8-0_slider_tooltip_min_width);padding:var(--_ui5-v2-8-0_slider_tooltip_padding);box-sizing:var(--_ui5-v2-8-0_slider_tooltip_border_box)}:host(:not([hidden])):host([editable-tooltip]) .ui5-slider-handle-container .ui5-slider-tooltip{border:none;background:none;box-shadow:none}:host([editable-tooltip]) .ui5-slider-tooltip{padding:0;box-shadow:none}.ui5-slider-tooltip [ui5-input]{width:100%;text-align:center}.ui5-slider-tooltip-value{position:relative;display:flex;justify-content:center;align-items:center}.ui5-slider-labels{position:absolute;top:1.25rem;margin:0;padding:0;white-space:nowrap}.ui5-slider-labels li{position:relative;list-style:none;padding-top:.3125rem;height:1rem;margin:0;text-align:center;display:inline-block;color:var(--_ui5-v2-8-0_slider_label_color);font-family:var(--sapFontFamily);font-size:var(--_ui5-v2-8-0_slider_label_fontsize);padding-top:0;box-sizing:border-box;display:inline-flex;justify-content:center;align-items:center;vertical-align:top}.ui5-slider-hidden-labels li:not(:first-child):not(:last-child){visibility:hidden}.ui5-slider-handle:focus .ui5-slider-tooltip{bottom:var(--_ui5-v2-8-0_slider_handle_focused_tooltip_distance)}.ui5-slider-tickmarks li.ui5-slider-tickmark-in-range{border-inline-start:1px solid var(--_ui5-v2-8-0_slider_tickmark_in_range_bg)}:host([show-tickmarks]) .ui5-slider-progress{height:var(--_ui5-v2-8-0_slider_no_tickmarks_progress_height);border:var(--_ui5-v2-8-0_slider_no_tickmarks_active_progress_border);left:var(--_ui5-v2-8-0_slider_no_tickmarks_active_progress_left);top:var(--_ui5-v2-8-0_slider_no_tickmarks_active_progress_top)}:host([show-tickmarks]) .ui5-slider-progress-container{top:var(--_ui5-v2-8-0_slider_no_tickmarks_progress_container_top)}.ui5-slider-handle:focus:after{content:"";display:var(--_ui5-v2-8-0_slider_handle_focus_visibility);width:calc(100% + (var(--sapContent_FocusWidth) * 2) + 2px);height:calc(100% + (var(--sapContent_FocusWidth) * 2) + 2px);border:var(--sapContent_FocusWidth) dotted var(--sapContent_FocusColor);position:absolute;border-radius:var(--_ui5-v2-8-0_slider_handle_border_radius);pointer-events:none}
`;

// node_modules/@ui5/webcomponents/dist/SliderBase.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SliderBase_1;
var SliderBase = SliderBase_1 = /**
 * @class
 *
 * ### Overview
 * @constructor
 * @extends UI5Element
 * @public
 */
class SliderBase2 extends UI5Element_default {
  async formElementAnchor() {
    return this.getFocusDomRefAsync();
  }
  constructor() {
    super();
    this.min = 0;
    this.max = 100;
    this.step = 1;
    this.labelInterval = 0;
    this.showTickmarks = false;
    this.showTooltip = false;
    this.editableTooltip = false;
    this.disabled = false;
    this.value = 0;
    this._tooltipVisibility = "hidden";
    this._labelsOverlapping = false;
    this._hiddenTickmarks = false;
    this._isInputValueValid = false;
    this.notResized = false;
    this._isUserInteraction = false;
    this._isInnerElementFocusing = false;
    this._labelWidth = 0;
    this._resizeHandler = this._handleResize.bind(this);
    this._moveHandler = this._handleMove.bind(this);
    this._upHandler = this._handleUp.bind(this);
    this._stateStorage = {
      step: void 0,
      min: void 0,
      max: void 0,
      labelInterval: void 0
    };
  }
  _handleMove(e) {
  }
  // eslint-disable-line
  _handleUp(e) {
  }
  // eslint-disable-line
  _onmousedown(e) {
  }
  // eslint-disable-line
  _handleActionKeyPress(e) {
  }
  // eslint-disable-line
  _updateInputValue() {
  }
  static get ACTION_KEYS() {
    return [
      isLeft,
      isRight,
      isUp,
      isDown,
      isLeftCtrl,
      isRightCtrl,
      isUpCtrl,
      isDownCtrl,
      isPlus,
      isMinus,
      isHome,
      isEnd,
      isPageUp,
      isPageDown,
      isEscape
    ];
  }
  static get MIN_SPACE_BETWEEN_TICKMARKS() {
    return 8;
  }
  static get TOOLTIP_VISIBILITY() {
    return {
      VISIBLE: "visible",
      HIDDEN: "hidden"
    };
  }
  static get renderer() {
    return JsxRenderer_default;
  }
  static get styles() {
    return SliderBase_css_default;
  }
  get classes() {
    return {
      root: {
        "ui5-slider-root-phone": isPhone()
      },
      labelContainer: {
        "ui5-slider-hidden-labels": this._labelsOverlapping
      }
    };
  }
  onEnterDOM() {
    ResizeHandler_default.register(this, this._resizeHandler);
  }
  onExitDOM() {
    ResizeHandler_default.deregister(this, this._resizeHandler);
  }
  onAfterRendering() {
    if (this.notResized) {
      this._resizeHandler();
    }
  }
  /** Shows the tooltip(s) if the `showTooltip` property is set to true
   * @private
   */
  _onmouseover() {
    if (this.showTooltip) {
      this._tooltipVisibility = SliderBase_1.TOOLTIP_VISIBILITY.VISIBLE;
    }
  }
  /**
   * Hides the tooltip(s) if the `showTooltip` property is set to true
   * @private
   */
  _onmouseout() {
    if (this.showTooltip && !this.shadowRoot.activeElement) {
      this._tooltipVisibility = SliderBase_1.TOOLTIP_VISIBILITY.HIDDEN;
    }
  }
  _onkeydown(e) {
    const target = e.target;
    if (isF2(e) && target.classList.contains("ui5-slider-handle")) {
      target.parentNode.querySelector(".ui5-slider-handle-container ui5-input").focus();
    }
    if (this.disabled || this._effectiveStep === 0 || target.hasAttribute("ui5-slider-handle")) {
      return;
    }
    if (SliderBase_1._isActionKey(e) && target && !target.hasAttribute("ui5-input")) {
      e.preventDefault();
      this._isUserInteraction = true;
      this._handleActionKeyPress(e);
    }
  }
  _onInputKeydown(e) {
    const target = e.target;
    if (isF2(e) && target.hasAttribute("ui5-input")) {
      target.parentNode.parentNode.querySelector(".ui5-slider-handle").focus();
    }
    if (isEnter(e)) {
      this._updateInputValue();
      this._updateValueFromInput(e);
    }
  }
  _onInputChange() {
    if (this._valueOnInteractionStart !== this.value) {
      this.fireDecoratorEvent("change");
    }
  }
  _onInputInput() {
    this.fireDecoratorEvent("input");
  }
  _updateValueFromInput(e) {
    const input = e.target;
    const value = parseFloat(input.value);
    this._isInputValueValid = value >= this._effectiveMin && value <= this._effectiveMax;
    if (!this._isInputValueValid) {
      return;
    }
    this.value = value;
  }
  _onKeyupBase() {
    if (this.disabled) {
      return;
    }
    this._isUserInteraction = false;
  }
  /**
   * Flags if an inner element is currently being focused
   * @private
   */
  _preserveFocus(isFocusing) {
    this._isInnerElementFocusing = isFocusing;
  }
  /**
   * Return if an inside element within the component is currently being focused
   * @private
   */
  _isFocusing() {
    return this._isInnerElementFocusing;
  }
  /**
   * Prevent focus out when inner element within the component is currently being in process of focusing in.
   * @private
   */
  _preventFocusOut() {
    this.focusInnerElement();
  }
  /**
   * Manages the focus between the component's inner elements
   * @protected
   */
  focusInnerElement() {
    this.focus();
  }
  /**
   * Handle the responsiveness of the Slider's UI elements when resizing
   * @private
   */
  _handleResize() {
    if (!this.showTickmarks) {
      return;
    }
    this.notResized = false;
    const spaceBetweenTickmarks = this._spaceBetweenTickmarks();
    if (spaceBetweenTickmarks < SliderBase_1.MIN_SPACE_BETWEEN_TICKMARKS) {
      this._hiddenTickmarks = true;
      this._labelsOverlapping = true;
    } else {
      this._hiddenTickmarks = false;
    }
    if (this.labelInterval <= 0 || this._hiddenTickmarks) {
      return;
    }
    const labelItems = this.shadowRoot.querySelectorAll(".ui5-slider-labels li");
    this._labelsOverlapping = [...labelItems].some((label) => label.scrollWidth > label.clientWidth);
  }
  /**
   * Called when the user starts interacting with the slider.
   * After a down event on the slider root, listen for move events on window, so the slider value
   * is updated even if the user drags the pointer outside the slider root.
   * @protected
   */
  handleDownBase(e) {
    const min = this._effectiveMin;
    const max = this._effectiveMax;
    const domRect = this.getBoundingClientRect();
    const directionStart = this.directionStart;
    const step = this._effectiveStep;
    const newValue = SliderBase_1.getValueFromInteraction(e, step, min, max, domRect, directionStart);
    this._isUserInteraction = true;
    window.addEventListener("mouseup", this._upHandler);
    window.addEventListener("touchend", this._upHandler);
    if (supportsTouch() && e instanceof TouchEvent) {
      window.addEventListener("touchmove", this._moveHandler);
    } else {
      window.addEventListener("mousemove", this._moveHandler);
    }
    this._handleFocusOnMouseDown(e);
    return newValue;
  }
  /**
   * Forward the focus to an inner inner part within the component on press
   * @private
   */
  _handleFocusOnMouseDown(e) {
    const currentlyFocusedElement = this.shadowRoot.activeElement;
    const elementToBeFocused = e.target;
    if ((!currentlyFocusedElement || currentlyFocusedElement !== elementToBeFocused) && !elementToBeFocused.hasAttribute("ui5-input")) {
      this._preserveFocus(true);
      this.focusInnerElement();
    }
  }
  /**
   * Called when the user finish interacting with the slider
   * Fires an `change` event indicating a final value change, after user interaction is finished.
   * @protected
   */
  handleUpBase() {
    window.removeEventListener("mouseup", this._upHandler);
    window.removeEventListener("touchend", this._upHandler);
    window.removeEventListener("mousemove", this._moveHandler);
    window.removeEventListener("touchmove", this._moveHandler);
    this._isUserInteraction = false;
    this._preserveFocus(false);
  }
  /**
   * Updates state storage for the value-related property
   * Fires an `input` event indicating a value change via interaction that is not yet finished.
   * @protected
   */
  updateStateStorageAndFireInputEvent(valueType) {
    this.storePropertyState(valueType);
    if (this._isUserInteraction) {
      this.fireDecoratorEvent("input");
    }
  }
  /**
   * Goes through the key shortcuts available for the component and returns 'true' if the event is triggered by one.
   * @private
   */
  static _isActionKey(e) {
    return this.ACTION_KEYS.some((actionKey) => actionKey(e));
  }
  /**
   * Locks the given value between min and max boundaries based on slider properties
   * @protected
   */
  static clipValue(value, min, max) {
    value = Math.min(Math.max(value, min), max);
    return value;
  }
  /**
   * Sets the slider value from an event
   * @protected
   */
  static getValueFromInteraction(e, stepSize, min, max, boundingClientRect, directionStart) {
    const pageX = this.getPageXValueFromEvent(e);
    const value = this.computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart);
    const steppedValue = this.getSteppedValue(value, stepSize, min);
    return this.clipValue(steppedValue, min, max);
  }
  /**
   * "Stepify" the raw value - calculate the new value depending on the specified step property
   * @protected
   */
  static getSteppedValue(value, stepSize, min) {
    const stepModuloValue = Math.abs((value - min) % stepSize);
    if (stepSize === 0 || stepModuloValue === 0) {
      return value;
    }
    value = stepModuloValue * 2 >= stepSize ? value + stepSize - stepModuloValue : value - stepModuloValue;
    const stepPrecision = SliderBase_1._getDecimalPrecisionOfNumber(stepSize);
    return Number(value.toFixed(stepPrecision));
  }
  /**
   * Gets pageX value from event on user interaction with the Slider
   * @protected
   */
  static getPageXValueFromEvent(e) {
    if (supportsTouch() && e instanceof TouchEvent) {
      if (e.targetTouches && e.targetTouches.length > 0) {
        return e.targetTouches[0].pageX;
      }
      return 0;
    }
    return e.pageX;
  }
  /**
   * Computes the new value (in %) from the pageX position of the cursor.
   * Returns the value rounded to a precision of at most 2 digits after decimal point.
   * @protected
   */
  static computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart) {
    const xRelativePosition = directionStart === "left" ? pageX - boundingClientRect[directionStart] : boundingClientRect[directionStart] - pageX;
    const percentageComplete = xRelativePosition / boundingClientRect.width;
    return min + percentageComplete * (max - min);
  }
  /**
   * Calculates the precision (decimal places) of a number, returns 0 if integer
   * Handles scientific notation cases.
   * @private
   */
  static _getDecimalPrecisionOfNumber(value) {
    if (Number.isInteger(value)) {
      return 0;
    }
    const match = String(value).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
    if (!match || match.length < 2) {
      return 0;
    }
    return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? Number(match[2]) : 0));
  }
  /**
   * In order to always keep the visual UI representation and the internal
   * state in sync, the component has a 'state storage' that is updated when the
   * current state is changed due to a user action.
   *
   * Check if the previously saved state is outdated. That would mean
   * a property has been changed programmatically because the previous state
   * is always updated in the interaction handlers.
   *
   * Will return true if any of the properties is not equal to its previously
   * stored value.
   * @protected
   */
  isCurrentStateOutdated() {
    return Object.entries(this._stateStorage).some(([propName, propValue]) => this[propName] !== propValue);
  }
  /**
   * Returns the last stored value of a property
   * @protected
   */
  getStoredPropertyState(prop) {
    return this._stateStorage[prop];
  }
  /**
   * Check if one or more properties have been updated compared to their last
   * saved values in the state storage.
   * @protected
   */
  isPropertyUpdated(...props) {
    return props.some((prop) => this.getStoredPropertyState(prop) !== this[prop]);
  }
  /**
   * Updates the previously saved in the _stateStorage values of one or more properties.
   * @protected
   */
  storePropertyState(...props) {
    props.forEach((prop) => {
      this._stateStorage[prop] = this[prop];
    });
  }
  /**
   * Returns the start side of a direction - left for LTR, right for RTL
   */
  get directionStart() {
    return this.effectiveDir === "rtl" ? "right" : "left";
  }
  /**
   * Calculates the labels amount, width and text and creates them
   * @private
   */
  _createLabels() {
    if (!this.labelInterval || !this.showTickmarks) {
      return;
    }
    const labelInterval = this.labelInterval;
    const step = this._effectiveStep;
    const newNumberOfLabels = (this._effectiveMax - this._effectiveMin) / (step * labelInterval);
    if (newNumberOfLabels === this._oldNumberOfLabels && this._oldMin === this._effectiveMin && this._oldMax === this._effectiveMax) {
      return;
    }
    this._oldMin = this._effectiveMin;
    this._oldMax = this._effectiveMax;
    this._oldNumberOfLabels = newNumberOfLabels;
    this._labelWidth = 100 / newNumberOfLabels;
    this._labelValues = [];
    const stepPrecision = SliderBase_1._getDecimalPrecisionOfNumber(step);
    for (let i = 0; i <= newNumberOfLabels; i++) {
      const labelItemNumber = (i * step * labelInterval + this._effectiveMin).toFixed(stepPrecision);
      this._labelValues.push(labelItemNumber);
    }
  }
  _handleActionKeyPressBase(e, affectedPropName) {
    const isUpAction = SliderBase_1._isIncreaseValueAction(e, this.directionStart);
    const isBigStep = SliderBase_1._isBigStepAction(e);
    const currentValue = this[affectedPropName];
    const min = this._effectiveMin;
    const max = this._effectiveMax;
    let step = this._effectiveStep;
    step = isBigStep && (max - min) / step > 10 ? (max - min) / 10 : step;
    if (isEnd(e)) {
      return max - currentValue;
    }
    if (isHome(e)) {
      return (currentValue - min) * -1;
    }
    return isUpAction ? step : step * -1;
  }
  static _isIncreaseValueAction(e, directionStart) {
    if (directionStart === "right") {
      return isUp(e) || isUpCtrl(e) || isLeft(e) || isLeftCtrl(e) || isPlus(e) || isPageUp(e);
    }
    return isUp(e) || isUpCtrl(e) || isRight(e) || isRightCtrl(e) || isPlus(e) || isPageUp(e);
  }
  static _isBigStepAction(e) {
    return isDownCtrl(e) || isUpCtrl(e) || isLeftCtrl(e) || isRightCtrl(e) || isPageUp(e) || isPageDown(e);
  }
  get _tickmarksCount() {
    return (this._effectiveMax - this._effectiveMin) / this._effectiveStep;
  }
  /**
   * Calculates space between tickmarks
   * @private
   */
  _spaceBetweenTickmarks() {
    return this.getBoundingClientRect().width / this._tickmarksCount;
  }
  /**
   * Notify in case of a invalid step value type
   * @private
   */
  _validateStep(step) {
    if (step === 0) {
      console.warn("The 'step' property must be a positive float number");
    }
    if (step < 0) {
      console.warn("The 'step' property must be a positive float number. The provided negative number has been converted to its positve equivalent");
    }
    if (Number.isNaN(step)) {
      console.warn("The 'step' property must be a positive float number. It has been set to its default value of 1");
    }
  }
  get _labels() {
    return this._labelValues || [];
  }
  /**
   * Normalizes a new `step` property value.
   * If tickmarks are enabled recreates them according to it.
   * @private
   */
  get _effectiveStep() {
    let step = this.step;
    if (step < 0) {
      step = Math.abs(step);
    }
    if (Number.isNaN(step)) {
      step = 1;
    }
    return step;
  }
  get _effectiveMin() {
    return Math.min(this.min, this.max);
  }
  get _effectiveMax() {
    return Math.max(this.min, this.max);
  }
  get _tabIndex() {
    return this.disabled ? -1 : 0;
  }
  get _ariaDescribedByHandleText() {
    return this.editableTooltip ? "ui5-slider-InputDesc" : void 0;
  }
  get _ariaLabelledByHandleText() {
    return this.accessibleName ? "ui5-slider-accName ui5-slider-sliderDesc" : "ui5-slider-sliderDesc";
  }
  get _ariaDescribedByInputText() {
    return "";
  }
  get _ariaLabelledByInputText() {
    return "";
  }
};
__decorate([
  property_default({ type: Number })
], SliderBase.prototype, "min", void 0);
__decorate([
  property_default({ type: Number })
], SliderBase.prototype, "max", void 0);
__decorate([
  property_default()
], SliderBase.prototype, "name", void 0);
__decorate([
  property_default({ type: Number })
], SliderBase.prototype, "step", void 0);
__decorate([
  property_default({ type: Number })
], SliderBase.prototype, "labelInterval", void 0);
__decorate([
  property_default({ type: Boolean })
], SliderBase.prototype, "showTickmarks", void 0);
__decorate([
  property_default({ type: Boolean })
], SliderBase.prototype, "showTooltip", void 0);
__decorate([
  property_default({ type: Boolean })
], SliderBase.prototype, "editableTooltip", void 0);
__decorate([
  property_default({ type: Boolean })
], SliderBase.prototype, "disabled", void 0);
__decorate([
  property_default()
], SliderBase.prototype, "accessibleName", void 0);
__decorate([
  property_default({ type: Number })
], SliderBase.prototype, "value", void 0);
__decorate([
  property_default()
], SliderBase.prototype, "_tooltipVisibility", void 0);
__decorate([
  property_default({ type: Boolean })
], SliderBase.prototype, "_labelsOverlapping", void 0);
__decorate([
  property_default({ type: Boolean })
], SliderBase.prototype, "_hiddenTickmarks", void 0);
__decorate([
  property_default({ type: Boolean })
], SliderBase.prototype, "_isInputValueValid", void 0);
SliderBase = SliderBase_1 = __decorate([
  event_strict_default("change", {
    bubbles: true
  }),
  event_strict_default("input", {
    bubbles: true
  })
  /**
   * @class
   *
   * ### Overview
   * @constructor
   * @extends UI5Element
   * @public
   */
], SliderBase);
var SliderBase_default = SliderBase;

// node_modules/@ui5/webcomponents-icons/dist/v4/direction-arrows.js
var name3 = "direction-arrows";
var pathData3 = "M507 244q5 5 5 12 0 6-5 11L394 379q-5 5-12 5-6 0-11-5t-5-11V144q0-12 10-15 2-1 6-1 8 0 12 4zM135 129q10 3 10 15v224q0 6-4.5 11t-11.5 5q-6 0-11-5L5 267q-5-5-5-11 0-7 5-12l113-112q4-4 11-4 4 0 6 1z";
var ltr3 = false;
var collection3 = "SAP-icons-v4";
var packageName3 = "@ui5/webcomponents-icons";
registerIcon(name3, { pathData: pathData3, ltr: ltr3, collection: collection3, packageName: packageName3 });

// node_modules/@ui5/webcomponents-icons/dist/v5/direction-arrows.js
var name4 = "direction-arrows";
var pathData4 = "M135 128q11 0 18 7.5t7 18.5v204q0 11-8 18.5t-18 7.5-17-7L8 275q-8-8-8-19t8-19l109-102q7-7 18-7zm369 109q8 8 8 19t-8 19L395 377q-7 7-17 7t-18-7.5-8-18.5V154q0-12 8-19t19-7q9 0 16 7z";
var ltr4 = false;
var collection4 = "SAP-icons-v5";
var packageName4 = "@ui5/webcomponents-icons";
registerIcon(name4, { pathData: pathData4, ltr: ltr4, collection: collection4, packageName: packageName4 });

// node_modules/@ui5/webcomponents-icons/dist/direction-arrows.js
var direction_arrows_default = "direction-arrows";

// node_modules/@ui5/webcomponents/dist/SliderBaseTemplate.js
function SliderBaseTemplate(hooks) {
  return jsxs("div", { class: {
    "ui5-slider-root": true,
    "ui5-slider-root-phone": isPhone()
  }, onMouseDown: this._onmousedown, onTouchStart: this._onmousedown, onMouseOver: this._onmouseover, onMouseOut: this._onmouseout, onKeyDown: this._onkeydown, onKeyUp: this._onKeyupBase, part: "root-container", children: [((hooks == null ? void 0 : hooks.handlesAriaText) || handlesAriaText).call(this), jsxs("div", { class: "ui5-slider-inner", children: [!!this.step && this.showTickmarks && jsxs(Fragment, { children: [jsx("ul", { class: "ui5-slider-tickmarks", children: this.tickmarksObject.map((tm) => jsx(Fragment, { children: tm ? jsx("li", { class: "ui5-slider-tickmark ui5-slider-tickmark-in-range" }) : jsx("li", { class: "ui5-slider-tickmark" }) })) }), !!this.labelInterval && jsx("ul", { class: {
    "ui5-slider-labels": true,
    "ui5-slider-hidden-labels": this._labelsOverlapping
  }, style: this.styles.labelContainer, children: this._labels.map((l) => jsx("li", { style: this.styles.label, children: l })) })] }), ((hooks == null ? void 0 : hooks.progressBar) || progressBar).call(this), ((hooks == null ? void 0 : hooks.handles) || handles).call(this)] }), this.accessibleName && jsx("span", { id: "ui5-slider-accName", class: "ui5-hidden-text", children: this.accessibleName }), jsx("span", { id: "ui5-slider-sliderDesc", class: "ui5-hidden-text", children: this._ariaLabelledByText }), this.editableTooltip && jsxs(Fragment, { children: [jsx("span", { id: "ui5-slider-InputDesc", class: "ui5-hidden-text", children: this._ariaDescribedByInputText }), jsx("span", { id: "ui5-slider-InputLabel", class: "ui5-hidden-text", children: this._ariaLabelledByInputText })] })] });
}
function handlesAriaText() {
}
function progressBar() {
}
function handles() {
}

// node_modules/@ui5/webcomponents/dist/SliderTemplate.js
function SliderTemplate() {
  return SliderBaseTemplate.call(this, {
    progressBar: progressBar2,
    handles: handles2
  });
}
function progressBar2() {
  return jsx("div", { class: "ui5-slider-progress-container", "aria-hidden": "true", part: "progress-container", children: jsx("div", { class: "ui5-slider-progress", style: this.styles.progress, onFocusOut: this._onfocusout, onFocusIn: this._onfocusin, tabIndex: -1, part: "progress-bar" }) });
}
function handles2() {
  return jsxs("div", { class: "ui5-slider-handle-container", style: this.styles.handle, part: "handle-container", children: [jsx("div", { class: "ui5-slider-handle", onFocusOut: this._onfocusout, onFocusIn: this._onfocusin, role: "slider", tabIndex: this._tabIndex, "aria-orientation": "horizontal", "aria-valuemin": this.min, "aria-valuemax": this.max, "aria-valuenow": this.value, "aria-labelledby": this._ariaLabelledByHandleText, "aria-disabled": this._ariaDisabled, "aria-keyshortcuts": "F2", "aria-describedby": this._ariaDescribedByHandleText, "data-sap-focus-ref": true, part: "handle", children: jsx(Icon_default, { name: direction_arrows_default, mode: "Decorative", part: "icon-slider", "slider-icon": true }) }), this.showTooltip && jsx("div", { class: "ui5-slider-tooltip", style: this.styles.tooltip, children: this.editableTooltip ? jsx(Input_default, { value: this._tooltipInputValue, valueState: this._tooltipInputValueState, type: "Number", accessibleNameRef: "ui5-slider-InputLabel", onFocusOut: this._onInputFocusOut, onKeyDown: this._onInputKeydown, onChange: this._onInputChange, onInput: this._onInputInput, "data-sap-ui-end-value": true, tabIndex: -1 }) : jsx("span", { class: "ui5-slider-tooltip-value", children: this.tooltipValue }) })] });
}

// node_modules/@ui5/webcomponents/dist/Slider.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Slider_1;
var Slider = Slider_1 = class Slider2 extends SliderBase_default {
  get formFormattedValue() {
    return this.value.toString();
  }
  constructor() {
    super();
    this.value = 0;
    this._progressPercentage = 0;
    this._handlePositionFromStart = 0;
    this._tooltipInputValue = this.value.toString();
    this._tooltipInputValueState = "None";
    this._stateStorage.value = void 0;
    this._lastValidInputValue = this.min.toString();
  }
  /**
   *
   * Check if the previously saved state is outdated. That would mean
   * either it is the initial rendering or that a property has been changed
   * programmatically - because the previous state is always updated in
   * the interaction handlers.
   *
   * Normalize current properties, update the previously stored state.
   * Update the visual UI representation of the Slider.
   *
   */
  onBeforeRendering() {
    if (this.editableTooltip) {
      this._updateInputValue();
    }
    if (!this.isCurrentStateOutdated()) {
      return;
    }
    this.notResized = true;
    this.syncUIAndState();
    this._updateHandleAndProgress(this.value);
  }
  syncUIAndState() {
    if (this.isPropertyUpdated("step")) {
      this._validateStep(this.step);
      this.storePropertyState("step");
    }
    if (this.isPropertyUpdated("min", "max", "value")) {
      this.storePropertyState("min", "max");
      this.value = SliderBase_default.clipValue(this.value, this._effectiveMin, this._effectiveMax);
      this.updateStateStorageAndFireInputEvent("value");
      this.storePropertyState("value");
    }
    if (this.labelInterval && this.showTickmarks) {
      this._createLabels();
    }
    if (this.isPropertyUpdated("labelInterval")) {
      this.storePropertyState("labelInterval");
    }
  }
  /**
   * Called when the user starts interacting with the slider
   * @private
   */
  _onmousedown(e) {
    if (this.disabled || this.step === 0 || e.target.hasAttribute("ui5-input")) {
      return;
    }
    const newValue = this.handleDownBase(e);
    this._valueOnInteractionStart = this.value;
    if (this._valueInitial === void 0) {
      this._valueInitial = this.value;
    }
    const ctor = this.constructor;
    if (!this._isHandlePressed(ctor.getPageXValueFromEvent(e))) {
      this._updateHandleAndProgress(newValue);
      this.value = newValue;
      this.updateStateStorageAndFireInputEvent("value");
    }
  }
  _onfocusin() {
    if (this._valueInitial === void 0) {
      this._valueInitial = this.value;
    }
    if (this.showTooltip) {
      this._tooltipVisibility = SliderBase_default.TOOLTIP_VISIBILITY.VISIBLE;
    }
  }
  _onfocusout(e) {
    var _a;
    if (this._isFocusing()) {
      this._preventFocusOut();
      return;
    }
    this._valueInitial = void 0;
    if (this.showTooltip && !((_a = e.relatedTarget) == null ? void 0 : _a.hasAttribute("ui5-input"))) {
      this._tooltipVisibility = SliderBase_default.TOOLTIP_VISIBILITY.HIDDEN;
    }
  }
  /**
   * Called when the user moves the slider
   * @private
   */
  _handleMove(e) {
    if (e.target.hasAttribute("ui5-input")) {
      return;
    }
    e.preventDefault();
    if (this.disabled || this._effectiveStep === 0) {
      return;
    }
    const ctor = this.constructor;
    const newValue = ctor.getValueFromInteraction(e, this._effectiveStep, this._effectiveMin, this._effectiveMax, this.getBoundingClientRect(), this.directionStart);
    this._updateHandleAndProgress(newValue);
    this.value = newValue;
    this.updateStateStorageAndFireInputEvent("value");
  }
  /** Called when the user finish interacting with the slider
   * @private
   */
  _handleUp(e) {
    if (e.target.hasAttribute("ui5-input")) {
      return;
    }
    if (this._valueOnInteractionStart !== this.value) {
      this.fireDecoratorEvent("change");
    }
    this.handleUpBase();
    this._valueOnInteractionStart = void 0;
  }
  _onInputFocusOut(e) {
    const tooltipInput = this.shadowRoot.querySelector("[ui5-input]");
    this._tooltipVisibility = SliderBase_default.TOOLTIP_VISIBILITY.HIDDEN;
    this._updateValueFromInput(e);
    if (!this._isInputValueValid) {
      tooltipInput.value = this._lastValidInputValue;
      this._isInputValueValid = true;
      this._tooltipInputValueState = "None";
    }
  }
  _updateInputValue() {
    const tooltipInput = this.shadowRoot.querySelector("[ui5-input]");
    if (!tooltipInput) {
      return;
    }
    this._isInputValueValid = parseFloat(tooltipInput.value) >= this.min && parseFloat(tooltipInput.value) <= this.max;
    if (!this._isInputValueValid) {
      this._tooltipInputValue = this._lastValidInputValue;
      this._isInputValueValid = true;
      this._tooltipInputValueState = "Negative";
      return;
    }
    this._tooltipInputValue = this.value.toString();
    this._lastValidInputValue = this._tooltipInputValue;
    this._tooltipInputValueState = "None";
  }
  /** Determines if the press is over the handle
   * @private
   */
  _isHandlePressed(clientX) {
    const sliderHandleDomRect = this._sliderHandle.getBoundingClientRect();
    return clientX >= sliderHandleDomRect.left && clientX <= sliderHandleDomRect.right;
  }
  /** Updates the UI representation of the progress bar and handle position
   * @private
   */
  _updateHandleAndProgress(newValue) {
    const max = this._effectiveMax;
    const min = this._effectiveMin;
    this._progressPercentage = (newValue - min) / (max - min);
    this._handlePositionFromStart = this._progressPercentage * 100;
  }
  _handleActionKeyPress(e) {
    const min = this._effectiveMin;
    const max = this._effectiveMax;
    const currentValue = this.value;
    const ctor = this.constructor;
    const newValue = isEscape(e) ? this._valueInitial : ctor.clipValue(this._handleActionKeyPressBase(e, "value") + currentValue, min, max);
    if (newValue !== currentValue) {
      this._updateHandleAndProgress(newValue);
      this.value = newValue;
      this.updateStateStorageAndFireInputEvent("value");
    }
  }
  get inputValue() {
    return this.value.toString();
  }
  get styles() {
    return {
      progress: {
        "transform": `scaleX(${this._progressPercentage})`,
        "transform-origin": `${this.directionStart} top`
      },
      handle: {
        [this.directionStart]: `${this._handlePositionFromStart}%`
      },
      label: {
        "width": `${this._labelWidth}%`
      },
      labelContainer: {
        "width": `100%`,
        [this.directionStart]: `-${this._labelWidth / 2}%`
      },
      tooltip: {
        "visibility": `${this._tooltipVisibility}`
      }
    };
  }
  get _sliderHandle() {
    return this.shadowRoot.querySelector(".ui5-slider-handle");
  }
  get tooltipValue() {
    const ctor = this.constructor;
    const stepPrecision = ctor._getDecimalPrecisionOfNumber(this._effectiveStep);
    return this.value.toFixed(stepPrecision);
  }
  get _ariaDisabled() {
    return this.disabled || void 0;
  }
  get _ariaLabelledByText() {
    return Slider_1.i18nBundle.getText(SLIDER_ARIA_DESCRIPTION);
  }
  get _ariaDescribedByInputText() {
    return Slider_1.i18nBundle.getText(SLIDER_TOOLTIP_INPUT_DESCRIPTION);
  }
  get _ariaLabelledByInputText() {
    return Slider_1.i18nBundle.getText(SLIDER_TOOLTIP_INPUT_LABEL);
  }
  get tickmarksObject() {
    const count = this._tickmarksCount;
    const arr = [];
    if (this._hiddenTickmarks) {
      return [true, false];
    }
    for (let i = 0; i <= count; i++) {
      arr.push(this._effectiveMin + i * this.step <= this.value);
    }
    return arr;
  }
};
__decorate2([
  property_default({ type: Number })
], Slider.prototype, "value", void 0);
__decorate2([
  i18n_default("@ui5/webcomponents")
], Slider, "i18nBundle", void 0);
Slider = Slider_1 = __decorate2([
  customElement_default({
    tag: "ui5-slider",
    languageAware: true,
    formAssociated: true,
    template: SliderTemplate
  })
], Slider);
Slider.define();
var Slider_default = Slider;

// node_modules/@ui5/webcomponents/dist/ColorPickerTemplate.js
function ColorPickerTemplate() {
  return jsxs("section", { class: "ui5-color-picker-root", children: [jsx("div", { class: "ui5-color-picker-main-color", style: { "background-color": `rgb(${this._mainValue.r}, ${this._mainValue.g}, ${this._mainValue.b})` }, onMouseDown: this._handleMouseDown, onMouseUp: this._handleMouseUp, onMouseMove: this._handleMouseMove, onMouseOut: this._handleMouseOut, children: jsx("div", { class: "ui5-color-picker-circle", style: {
    left: `${this._selectedCoordinates.x}px`,
    top: `${this._selectedCoordinates.y}px`
  } }) }), jsxs("div", { class: "ui5-color-picker-sliders-wrapper", children: [jsx(Slider_default, { disabled: this.inputsDisabled, class: "ui5-color-picker-hue-slider", min: 0, max: 360, step: 1, value: this._hue, accessibleName: this.hueSliderLabel, showTooltip: true, onInput: this._handleHueInput }), this._isDefaultPickerMode && jsx(Slider_default, { disabled: this.inputsDisabled, class: "ui5-color-picker-alpha-slider", min: 0, max: 1, step: 0.01, value: this._alpha, accessibleName: this.alphaSliderLabel, showTooltip: true, onInput: this._handleAlphaInput })] }), jsxs("div", { class: "ui5-color-picker-current-color", children: [jsxs("div", { class: "ui5-color-picker-colors-wrapper", children: [jsx("span", { class: "ui5-color-picker-white" }), jsx("span", { class: "ui5-color-picker-color", children: jsx("div", { class: "ui5-color-picker-color-inner", style: { "background-color": this._colorValue.toRGBString() } }) })] }), jsxs("div", { class: "ui5-color-picker-hex-input-wrapper", children: [jsx(Label_default, { children: "Hex" }), jsx(Input_default, { class: "ui5-color-picker-hex-input", value: this.HEX, onKeyDown: this._onkeydown, accessibleName: this.hexInputLabel, onChange: this._handleHEXChange, valueState: this.hexInputErrorState })] })] }), this._isDefaultPickerMode && jsxs("div", { class: "ui5-color-channel-inputs-wrapper", "onui5-change": this._handleColorInputChange, children: [this.colorChannelInputs.map((input) => jsxs(Fragment, { children: [jsxs("div", { class: "ui5-color-channel", children: [jsx(Input_default, { id: input.id, class: "ui5-color-channel-input", disabled: this.inputsDisabled, accessibleName: input.accessibleName, value: String(input.value) }), jsx(Label_default, { children: input.label })] }), jsx("div", { class: "ui5-color-channel-percentage-label", children: input.showPercentSymbol && jsx(Label_default, { children: "%" }) })] })), jsxs("div", { class: "ui5-color-channel", children: [jsx(Input_default, { id: "alpha", disabled: this.inputsDisabled, class: "ui5-color-channel-input", value: String(this._alpha), accessibleName: this.alphaInputLabel, onChange: this._handleAlphaChange, onInput: this._handleAlphaInput }), jsx(Label_default, { children: "A" })] }), jsx("div", { children: jsx(Button_default, { class: "ui5-color-channel-toggle", id: "toggle-picker-mode", icon: "expand", design: "Transparent", tooltip: this.toggleModeTooltip, onClick: this._togglePickerMode }) })] })] });
}

// node_modules/@ui5/webcomponents/dist/generated/themes/ColorPicker.css.js
registerThemePropertiesLoader("@ui5/webcomponents-theming", "sap_horizon", async () => parameters_bundle_css_default);
registerThemePropertiesLoader("@ui5/webcomponents", "sap_horizon", async () => parameters_bundle_css_default2);
var ColorPicker_css_default = `:host(:not([hidden])){display:inline-block}.ui5-color-picker-root{width:100%;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center}.ui5-color-picker-main-color{width:16rem;height:16rem;position:relative;margin-bottom:var(--_ui5-v2-8-0_color_picker_main_color_margin_bottom);border:.0625rem solid var(--sapContent_ForegroundBorderColor);background-size:100%;background-image:-webkit-linear-gradient(left,#000,rgba(0,0,0,0)),-webkit-linear-gradient(top,rgba(255,255,255,0),#fff);background-image:-moz-linear-gradient(left,#000,rgba(0,0,0,0)),-moz-linear-gradient(top,rgba(255,255,255,0),#fff);background-image:linear-gradient(left,#000,#0000),linear-gradient(top,#fff0,#fff);background-image:-webkit-linear-gradient(left,#000,rgba(0,0,0,0),#fff),-webkit-linear-gradient(top,rgba(128,128,128,0),#808080);background-image:-moz-linear-gradient(left,#000,rgba(0,0,0,0),#fff),-moz-linear-gradient(top,rgba(128,128,128,0),#808080);background-image:linear-gradient(left,#000,#0000,#fff),linear-gradient(top,#80808000,gray);user-select:none;-moz-user-select:none}.ui5-color-picker-circle{position:absolute;box-sizing:border-box;width:.8125rem;height:.8125rem;border:var(--_ui5-v2-8-0_color_picker_circle_outer_border);border-radius:.6875rem;pointer-events:none}.ui5-color-picker-circle:after{content:"";position:absolute;width:var(--_ui5-v2-8-0_color_picker_circle_inner_circle_size);height:var(--_ui5-v2-8-0_color_picker_circle_inner_circle_size);border:var(--_ui5-v2-8-0_color_picker_circle_inner_border);border-radius:.9375rem;pointer-events:none}.ui5-color-picker-sliders-wrapper{width:calc(100% - .9375rem);margin-left:-.9375rem;padding-bottom:.25rem}[ui5-slider]{--_ui5-v2-8-0_slider_active_progress_border: none;--_ui5-v2-8-0_slider_progress_box_sizing: content-box;height:var(--_ui5-v2-8-0_color_picker_sliders_height)}[ui5-slider]::part(handle){width:var(--_ui5-v2-8-0_color_picker_slider_handle_width);height:var(--_ui5-v2-8-0_color_picker_slider_handle_height);background:transparent;box-sizing:border-box}[ui5-slider]::part(handle-container){margin-top:var(--_ui5-v2-8-0_color_picker_slider_handle_container_margin_top);margin-inline-start:-.125rem;z-index:2}[ui5-slider]::part(handle):after{content:"";border:.125rem solid var(--_ui5-v2-8-0_color_picker_slider_handle_inner_border_color);display:block;height:var(--_ui5-v2-8-0_color_picker_slider_handle_after_height);border-radius:1rem;width:100%;box-sizing:border-box}[ui5-slider]::part(root-container){padding:var(--_ui5-v2-8-0_color_picker_slider_spacing) 0}[ui5-slider]::part(progress-container){width:calc(100% + .6875rem);height:var(--_ui5-v2-8-0_color_picker_slider_progress_container_height);position:absolute;margin-top:var(--_ui5-v2-8-0_color_picker_slider_container_margin_top);border-radius:0;border:.0625rem solid var(--sapField_BorderColor)}[ui5-slider].ui5-color-picker-hue-slider::part(progress-container){background-size:100%;background-image:-webkit-linear-gradient(left,#f00,#ff0,#0f0,#0ff,#00f,#f0f,#f00);background-image:-moz-linear-gradient(left,#f00,#ff0,#0f0,#0ff,#00f,#f0f,#f00);background-image:linear-gradient(left,red,#ff0,#0f0,#0ff,#00f,#f0f,red);background-color:none}[ui5-slider].ui5-color-picker-alpha-slider::part(progress-container){background-image:-webkit-linear-gradient(left,rgba(65,120,13,0),var(--ui5-v2-8-0_Color_Picker_Progress_Container_Color)),url(data:image/png;base64,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)}[ui5-slider]::part(progress-bar){background:transparent}.ui5-color-picker-current-color{width:100%;display:flex;justify-content:space-between;align-items:center}.ui5-color-picker-colors-wrapper{display:flex;flex-wrap:nowrap;height:var(--_ui5-v2-8-0_color_picker_colors_wrapper_height);border:.0625rem solid var(--sapField_BorderColor)}.ui5-color-picker-white,.ui5-color-picker-color{width:3.1rem;background:#fff;display:block}.ui5-color-picker-color{background-image:url(data:image/png;base64,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)}.ui5-color-picker-color-inner{width:100%;height:100%}.ui5-color-picker-hex-input-wrapper{display:flex;align-items:center;flex-wrap:nowrap}.ui5-color-picker-hex-input{width:var(--_ui5-v2-8-0_color_channel_hex_input_width);min-width:4.5rem;margin-left:.2rem}.ui5-color-channel-inputs-wrapper{display:flex;justify-content:space-around;width:100%;align-items:center}.ui5-color-channel{display:flex;flex-direction:column;align-items:center;margin-top:var(--_ui5-v2-8-0-color_channel_margin_top);position:relative}.ui5-color-channel-input{width:2.5rem;min-width:2.5rem;text-align:center}.ui5-color-channel-input::part(input){min-width:initial;padding:0 .25rem}.ui5-color-channel-percentage-label{width:1rem;margin-top:var(--_ui5-v2-8-0_color_channel_toggle_button_margin-top)}.ui5-color-channel-toggle{min-width:var(--_ui5-v2-8-0_color_channel_toggle_button_width);margin-inline-start:.5rem;margin-top:var(--_ui5-v2-8-0_color_channel_toggle_button_margin-top)}.ui5-color-picker-hue-slider::part(progress-container):before,.ui5-color-picker-alpha-slider::part(progress-container):before,.ui5-color-picker-hue-slider::part(progress-container):after,.ui5-color-picker-alpha-slider::part(progress-container):after,[ui5-slider].ui5-color-picker-hue-slider::part(icon-slider),[ui5-slider].ui5-color-picker-alpha-slider::part(icon-slider){display:none}.ui5-color-picker-alpha-slider::part(handle),.ui5-color-picker-hue-slider::part(handle){box-shadow:var(--_ui5-v2-8-0_color_picker_slider_handle_box_shadow);border:var(--_ui5-v2-8-0_color_picker_slider_handle_border)}.ui5-color-picker-alpha-slider::part(handle):hover,.ui5-color-picker-hue-slider::part(handle):hover{border:var(--_ui5-v2-8-0_color_picker_slider_handle_outline_hover)}.ui5-color-picker-alpha-slider::part(handle):focus,.ui5-color-picker-hue-slider::part(handle):focus{outline:var(--_ui5-v2-8-0_color_picker_slider_handle_outline_focus);outline-offset:.0625rem}.ui5-color-picker-alpha-slider::part(handle):focus:before,.ui5-color-picker-hue-slider::part(handle):focus:before{content:"";border:var(--_ui5-v2-8-0_color_picker_slider_handle_inline_focus);display:block;height:var(--_ui5-v2-8-0_color_picker_slider_handle_focus_height);border-radius:1rem;box-sizing:border-box;position:absolute;inset:-.1875rem -.1875rem .125rem}.ui5-color-picker-alpha-slider::part(handle):before,.ui5-color-picker-hue-slider::part(handle):before{display:none}:dir(rtl) [ui5-slider].ui5-color-picker-hue-slider::part(progress-container){background-image:-webkit-linear-gradient(right,#f00,#ff0,#0f0,#0ff,#00f,#f0f,#f00);background-image:-moz-linear-gradient(right,#f00,#ff0,#0f0,#0ff,#00f,#f0f,#f00);background-image:linear-gradient(right,red,#ff0,#0f0,#0ff,#00f,#f0f,red)}:dir(rtl) .ui5-color-picker-alpha-slider::part(handle),:dir(rtl) .ui5-color-picker-hue-slider::part(handle){--_ui5-v2-8-0_slider_handle_margin_left: 0}:dir(rtl) .ui5-color-picker-sliders-wrapper{margin-left:.625rem}
`;

// node_modules/@ui5/webcomponents/dist/ColorPicker.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ColorPicker_1;
var PICKER_POINTER_WIDTH = 6.5;
var ColorPicker = ColorPicker_1 = class ColorPicker2 extends UI5Element_default {
  async formElementAnchor() {
    return this.getFocusDomRefAsync();
  }
  get formFormattedValue() {
    return this.value;
  }
  constructor() {
    super();
    this.value = "rgba(255,255,255,1)";
    this.simplified = false;
    this._alpha = 1;
    this._hue = 0;
    this._isSelectedColorChanged = false;
    this._isHueValueChanged = false;
    this._wrongHEX = false;
    this._displayHSL = false;
    this._colorValue = new ColorValue_default();
    this._selectedCoordinates = {
      x: 256 - PICKER_POINTER_WIDTH,
      y: 256 - PICKER_POINTER_WIDTH
    };
    this._mainValue = {
      r: 255,
      g: 0,
      b: 0
    };
    this.selectedHue = 0;
    this.mouseDown = false;
    this.mouseIn = false;
  }
  onBeforeRendering() {
    const valueAsRGB = getRGBColor(this.value);
    if (!this._isColorValueEqual(valueAsRGB)) {
      this._colorValue.RGB = valueAsRGB;
    }
    const alpha = getAlpha(this.value);
    if (alpha !== this._colorValue.Alpha) {
      this._colorValue.Alpha = alpha;
      this._alpha = this._colorValue.Alpha;
    }
    const tempColor = this._colorValue.toRGBString();
    this._updateColorGrid();
    this.style.setProperty(getScopedVarName("--ui5_Color_Picker_Progress_Container_Color"), tempColor);
  }
  _handleMouseDown(e) {
    this.mouseDown = true;
    this.mouseIn = true;
    this._changeSelectedColor(e.offsetX, e.offsetY);
  }
  _handleMouseUp() {
    this.mouseDown = false;
  }
  _handleMouseOut(e) {
    if (!this.mouseIn || !this.mouseDown) {
      return;
    }
    const target = e.target;
    const offsetHeight = target.offsetHeight;
    const offsetWidth = target.offsetWidth;
    const isLeft2 = e.offsetX <= 0;
    const isUp2 = e.offsetY <= 0;
    const isDown2 = e.offsetY >= target.offsetHeight;
    const isRight2 = e.offsetX >= target.offsetWidth;
    let x, y;
    if (isLeft2) {
      x = 0;
    } else if (isRight2) {
      x = offsetWidth;
    } else {
      x = e.offsetX;
    }
    if (isUp2) {
      y = 0;
    } else if (isDown2) {
      y = offsetHeight;
    } else {
      y = e.offsetY;
    }
    this._changeSelectedColor(x, y);
    this.mouseIn = false;
    this.mouseDown = false;
  }
  _handleMouseMove(e) {
    if (!this.mouseDown || !this.mouseIn) {
      return;
    }
    this._changeSelectedColor(e.offsetX, e.offsetY);
  }
  _handleAlphaInput(e) {
    const aphaInputValue = String(e.currentTarget.value);
    this._alpha = parseFloat(aphaInputValue);
    if (Number.isNaN(this._alpha)) {
      this._alpha = 1;
    }
    this._colorValue.Alpha = this._alpha;
    this._isHueValueChanged = true;
    const color = this._colorValue.toRGBString();
    this._setValue(color);
  }
  _handleHueInput(e) {
    this.selectedHue = e.target.value;
    this._hue = this.selectedHue;
    this._setMainColor(this._hue);
    this._isHueValueChanged = true;
    this._colorValue.H = this._hue;
    const color = this._colorValue.toRGBString();
    this._setValue(color);
  }
  _handleHEXChange(e) {
    const input = e.target;
    let inputValueLowerCase = input.value.toLowerCase();
    if (inputValueLowerCase.length === 3) {
      inputValueLowerCase = `${inputValueLowerCase[0]}${inputValueLowerCase[0]}${inputValueLowerCase[1]}${inputValueLowerCase[1]}${inputValueLowerCase[2]}${inputValueLowerCase[2]}`;
    }
    this._colorValue.HEX = inputValueLowerCase;
    const isValidColor = this._colorValue.isColorValueValid();
    if (isValidColor && input.value !== inputValueLowerCase) {
      this._wrongHEX = false;
      input.value = inputValueLowerCase;
    }
    if (!isValidColor) {
      this._wrongHEX = true;
    } else {
      this._wrongHEX = false;
      const color = this._colorValue.toRGBString();
      this._setValue(color);
    }
  }
  _togglePickerMode() {
    this._displayHSL = !this._displayHSL;
  }
  _handleColorInputChange(e) {
    const target = e.target;
    const targetValue = parseInt(target.value) || 0;
    switch (target.id) {
      case "red":
        this._colorValue.R = targetValue;
        break;
      case "green":
        this._colorValue.G = targetValue;
        break;
      case "blue":
        this._colorValue.B = targetValue;
        break;
      case "hue":
        this._colorValue.H = targetValue;
        break;
      case "saturation":
        this._colorValue.S = targetValue;
        break;
      case "light":
        this._colorValue.L = targetValue;
        break;
    }
    const color = this._colorValue.toRGBString();
    this._setValue(color);
    this._updateColorGrid();
  }
  _setMainColor(hueValue) {
    const hueValueMod = hueValue * 4.251;
    if (hueValueMod <= 255) {
      this._mainValue = {
        r: 255,
        g: hueValueMod,
        b: 0
      };
    } else if (hueValueMod <= 510) {
      this._mainValue = {
        r: 255 - (hueValueMod - 255),
        g: 255,
        b: 0
      };
    } else if (hueValueMod <= 765) {
      this._mainValue = {
        r: 0,
        g: 255,
        b: hueValueMod - 510
      };
    } else if (hueValueMod <= 1020) {
      this._mainValue = {
        r: 0,
        g: 765 - (hueValueMod - 255),
        b: 255
      };
    } else if (hueValueMod <= 1275) {
      this._mainValue = {
        r: hueValueMod - 1020,
        g: 0,
        b: 255
      };
    } else {
      this._mainValue = {
        r: 255,
        g: 0,
        b: 1275 - (hueValueMod - 255)
      };
    }
  }
  _handleAlphaChange() {
    this._alpha = this._alpha < 0 ? 0 : this._alpha;
    this._alpha = this._alpha > 1 ? 1 : this._alpha;
    this._colorValue.Alpha = this._alpha;
  }
  _changeSelectedColor(x, y) {
    this._selectedCoordinates = {
      x: x - PICKER_POINTER_WIDTH,
      // Center the coordinates, because of the width of the circle
      y: y - PICKER_POINTER_WIDTH
      // Center the coordinates, because of the height of the circle
    };
    this._isSelectedColorChanged = true;
    const tempColor = this._calculateColorFromCoordinates(x, y);
    if (tempColor) {
      this._colorValue.HSL = tempColor;
      const color = this._colorValue.toRGBString();
      this._setValue(color);
    }
  }
  _onkeydown(e) {
    if (isEnter(e)) {
      this._handleHEXChange(e);
    }
  }
  _calculateColorFromCoordinates(x, y) {
    const h = this._hue;
    let s = +(1 - y / 256).toFixed(2);
    let l = +(x / 256).toFixed(2);
    if (Number.isNaN(s) || Number.isNaN(l)) {
      return;
    }
    s = Math.max(0, Math.min(1, s));
    l = Math.max(0, Math.min(1, l));
    return {
      h: Math.round(h),
      s: Math.round(s * 100),
      l: Math.round(l * 100)
    };
  }
  _setValue(color) {
    this.value = color;
    this._wrongHEX = !this._colorValue.isColorValueValid();
    this.fireDecoratorEvent("change");
  }
  _updateColorGrid() {
    const hslColours = this._colorValue.HSL;
    this._selectedCoordinates = {
      x: hslColours.l * 2.56 - PICKER_POINTER_WIDTH,
      // Center the coordinates, because of the width of the circle
      y: 256 - hslColours.s * 2.56 - PICKER_POINTER_WIDTH
      // Center the coordinates, because of the height of the circle
    };
    if (this._isSelectedColorChanged) {
      this._isSelectedColorChanged = false;
    } else if (this._isHueValueChanged) {
      this._isHueValueChanged = false;
      this._hue = this.selectedHue ? this.selectedHue : this._hue;
    } else {
      this._hue = hslColours.h;
    }
    this._setMainColor(this._hue);
  }
  _isColorValueEqual(value) {
    return this._colorValue.R === value.r && this._colorValue.G === value.g && this._colorValue.B === value.b;
  }
  get hueSliderLabel() {
    return ColorPicker_1.i18nBundle.getText(COLORPICKER_HUE_SLIDER);
  }
  get alphaSliderLabel() {
    return ColorPicker_1.i18nBundle.getText(COLORPICKER_ALPHA_SLIDER);
  }
  get hexInputLabel() {
    return ColorPicker_1.i18nBundle.getText(COLORPICKER_HEX);
  }
  get redInputLabel() {
    return ColorPicker_1.i18nBundle.getText(COLORPICKER_RED);
  }
  get greenInputLabel() {
    return ColorPicker_1.i18nBundle.getText(COLORPICKER_GREEN);
  }
  get blueInputLabel() {
    return ColorPicker_1.i18nBundle.getText(COLORPICKER_BLUE);
  }
  get hueInputLabel() {
    return ColorPicker_1.i18nBundle.getText(COLORPICKER_HUE);
  }
  get saturationInputLabel() {
    return ColorPicker_1.i18nBundle.getText(COLORPICKER_SATURATION);
  }
  get lightInputLabel() {
    return ColorPicker_1.i18nBundle.getText(COLORPICKER_LIGHT);
  }
  get alphaInputLabel() {
    return ColorPicker_1.i18nBundle.getText(COLORPICKER_ALPHA);
  }
  get toggleModeTooltip() {
    return ColorPicker_1.i18nBundle.getText(COLORPICKER_TOGGLE_MODE_TOOLTIP);
  }
  get inputsDisabled() {
    return this._wrongHEX ? true : void 0;
  }
  get hexInputErrorState() {
    return this._wrongHEX ? "Negative" : "None";
  }
  get rgbInputs() {
    const redInput = {
      id: "red",
      value: this._colorValue.R,
      label: "R",
      accessibleName: this.redInputLabel
    };
    const greenInput = {
      id: "green",
      value: this._colorValue.G,
      label: "G",
      accessibleName: this.greenInputLabel
    };
    const blueInput = {
      id: "blue",
      value: this._colorValue.B,
      label: "B",
      accessibleName: this.blueInputLabel
    };
    return [redInput, greenInput, blueInput];
  }
  get hslInputs() {
    const hueInput = {
      id: "hue",
      value: this._colorValue.H,
      label: "H",
      accessibleName: this.hueInputLabel
    };
    const saturationInput = {
      id: "saturation",
      value: this._colorValue.S,
      label: "S",
      accessibleName: this.saturationInputLabel,
      showPercentSymbol: true
    };
    const lightInput = {
      id: "light",
      value: this._colorValue.L,
      label: "L",
      accessibleName: this.lightInputLabel,
      showPercentSymbol: true
    };
    return [hueInput, saturationInput, lightInput];
  }
  get HEX() {
    return this._colorValue.HEX;
  }
  get colorChannelInputs() {
    return this._displayHSL ? this.hslInputs : this.rgbInputs;
  }
  get _isDefaultPickerMode() {
    return !this.simplified;
  }
};
__decorate3([
  property_default()
], ColorPicker.prototype, "value", void 0);
__decorate3([
  property_default()
], ColorPicker.prototype, "name", void 0);
__decorate3([
  property_default({ type: Boolean })
], ColorPicker.prototype, "simplified", void 0);
__decorate3([
  property_default({ type: Object })
], ColorPicker.prototype, "_mainValue", void 0);
__decorate3([
  property_default({ type: Object })
], ColorPicker.prototype, "_colorValue", void 0);
__decorate3([
  property_default({ type: Object })
], ColorPicker.prototype, "_selectedCoordinates", void 0);
__decorate3([
  property_default({ type: Number })
], ColorPicker.prototype, "_alpha", void 0);
__decorate3([
  property_default({ type: Number })
], ColorPicker.prototype, "_hue", void 0);
__decorate3([
  property_default({ type: Boolean })
], ColorPicker.prototype, "_isSelectedColorChanged", void 0);
__decorate3([
  property_default({ type: Boolean })
], ColorPicker.prototype, "_isHueValueChanged", void 0);
__decorate3([
  property_default({ type: Boolean })
], ColorPicker.prototype, "_wrongHEX", void 0);
__decorate3([
  property_default({ type: Boolean })
], ColorPicker.prototype, "_displayHSL", void 0);
__decorate3([
  i18n_default("@ui5/webcomponents")
], ColorPicker, "i18nBundle", void 0);
ColorPicker = ColorPicker_1 = __decorate3([
  customElement_default({
    tag: "ui5-color-picker",
    renderer: JsxRenderer_default,
    formAssociated: true,
    styles: ColorPicker_css_default,
    template: ColorPickerTemplate,
    shadowRootOptions: { delegatesFocus: true }
  }),
  event_strict_default("change", {
    bubbles: true
  })
], ColorPicker);
ColorPicker.define();
var ColorPicker_default = ColorPicker;

export {
  SliderBase_default,
  direction_arrows_default,
  SliderBaseTemplate,
  ColorPicker_default
};
//# sourceMappingURL=chunk-4LV27K6S.js.map
