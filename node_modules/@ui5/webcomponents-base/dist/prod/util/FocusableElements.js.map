{
  "version": 3,
  "sources": ["../../../src/util/FocusableElements.ts"],
  "sourcesContent": ["import isElementHidden from \"./isElementHidden.js\";\nimport isElementClickable from \"./isElementClickable.js\";\nimport { instanceOfUI5Element } from \"../UI5Element.js\";\nimport { isSafari } from \"../Device.js\";\n\ntype FocusableElementPromise = Promise<HTMLElement | null>;\n\nconst isFocusTrap = (el: HTMLElement) => {\n\treturn el.hasAttribute(\"data-ui5-focus-trap\");\n};\n\nconst isScrollable = (el: HTMLElement) => {\n\tconst computedStyle = getComputedStyle(el);\n\n\treturn (el.scrollHeight > el.clientHeight && [\"scroll\", \"auto\"].indexOf(computedStyle.overflowY) >= 0)\n\t\t|| (el.scrollWidth > el.clientWidth && [\"scroll\", \"auto\"].indexOf(computedStyle.overflowX) >= 0);\n};\n\nconst getFirstFocusableElement = async (container: HTMLElement, startFromContainer?: boolean): FocusableElementPromise => {\n\tif (!container || isElementHidden(container)) {\n\t\treturn null;\n\t}\n\n\treturn findFocusableElement(container, true, startFromContainer);\n};\n\nconst getLastFocusableElement = async (container: HTMLElement, startFromContainer?: boolean): FocusableElementPromise => {\n\tif (!container || isElementHidden(container)) {\n\t\treturn null;\n\t}\n\n\treturn findFocusableElement(container, false, startFromContainer);\n};\n\nconst isElemFocusable = (el: HTMLElement) => {\n\treturn el.hasAttribute(\"data-ui5-focus-redirect\") || !isElementHidden(el);\n};\n\nconst findFocusableElement = async (container: HTMLElement, forward: boolean, startFromContainer?: boolean): FocusableElementPromise => {\n\tlet child: HTMLElement | undefined;\n\tlet assignedElements;\n\tlet currentIndex = -1;\n\n\tif (container.shadowRoot) {\n\t\tchild = forward ? container.shadowRoot.firstChild as HTMLElement : container.shadowRoot.lastChild as HTMLElement;\n\t} else if (container instanceof HTMLSlotElement && container.assignedNodes()) {\n\t\tassignedElements = container.assignedNodes();\n\t\tcurrentIndex = forward ? 0 : assignedElements.length - 1;\n\t\tchild = assignedElements[currentIndex] as HTMLElement;\n\t} else if (startFromContainer) {\n\t\tchild = container;\n\t} else {\n\t\tchild = forward ? container.firstElementChild as HTMLElement : container.lastElementChild as HTMLElement;\n\t}\n\n\tlet focusableDescendant;\n\n\t/* eslint-disable no-await-in-loop */\n\n\twhile (child) {\n\t\tconst originalChild: HTMLElement | undefined = child;\n\n\t\tif (!isElementHidden(originalChild)) {\n\t\t\tif (instanceOfUI5Element(child)) {\n\t\t\t\tchild = await child.getFocusDomRefAsync();\n\t\t\t}\n\n\t\t\tif (!child || isElementHidden(child)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (child.nodeType === 1 && isElemFocusable(child) && !isFocusTrap(child)) {\n\t\t\t\tif (isElementClickable(child)) {\n\t\t\t\t\treturn (child && typeof child.focus === \"function\") ? child : null;\n\t\t\t\t}\n\n\t\t\t\tfocusableDescendant = await findFocusableElement(child, forward);\n\n\t\t\t\t// check if it is a keyboard focusable scroll container\n\t\t\t\tif (!isSafari() && !focusableDescendant && isScrollable(child)) {\n\t\t\t\t\treturn (child && typeof child.focus === \"function\") ? child : null;\n\t\t\t\t}\n\n\t\t\t\tif (focusableDescendant) {\n\t\t\t\t\treturn (focusableDescendant && typeof focusableDescendant.focus === \"function\") ? focusableDescendant : null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tchild = forward ? originalChild.nextSibling as HTMLElement : originalChild.previousSibling as HTMLElement;\n\n\t\t// If the child element is not part of the currently assigned element,\n\t\t// we have to check the next/previous element assigned to the slot or continue with the next/previous sibling of the slot,\n\t\t// otherwise, the nextSibling/previousSibling is the next element inside the light DOM\n\t\tif (assignedElements && !assignedElements[currentIndex].contains(child)) {\n\t\t\tcurrentIndex = forward ? currentIndex + 1 : currentIndex - 1;\n\n\t\t\tchild = assignedElements[currentIndex] as HTMLElement;\n\t\t}\n\t}\n\n\t/* eslint-enable no-await-in-loop */\n\n\treturn null;\n};\n\nexport {\n\tgetFirstFocusableElement,\n\tgetLastFocusableElement,\n};\n"],
  "mappings": "aAAA,OAAOA,MAAqB,uBAC5B,OAAOC,MAAwB,0BAC/B,OAAS,wBAAAC,MAA4B,mBACrC,OAAS,YAAAC,MAAgB,eAIzB,MAAMC,EAAeC,GACbA,EAAG,aAAa,qBAAqB,EAGvCC,EAAgBD,GAAoB,CACzC,MAAME,EAAgB,iBAAiBF,CAAE,EAEzC,OAAQA,EAAG,aAAeA,EAAG,cAAgB,CAAC,SAAU,MAAM,EAAE,QAAQE,EAAc,SAAS,GAAK,GAC/FF,EAAG,YAAcA,EAAG,aAAe,CAAC,SAAU,MAAM,EAAE,QAAQE,EAAc,SAAS,GAAK,CAChG,EAEMC,EAA2B,MAAOC,EAAwBC,IAC3D,CAACD,GAAaT,EAAgBS,CAAS,EACnC,KAGDE,EAAqBF,EAAW,GAAMC,CAAkB,EAG1DE,EAA0B,MAAOH,EAAwBC,IAC1D,CAACD,GAAaT,EAAgBS,CAAS,EACnC,KAGDE,EAAqBF,EAAW,GAAOC,CAAkB,EAG3DG,EAAmBR,GACjBA,EAAG,aAAa,yBAAyB,GAAK,CAACL,EAAgBK,CAAE,EAGnEM,EAAuB,MAAOF,EAAwBK,EAAkBJ,IAA0D,CACvI,IAAIK,EACAC,EACAC,EAAe,GAEfR,EAAU,WACbM,EAAQD,EAAUL,EAAU,WAAW,WAA4BA,EAAU,WAAW,UAC9EA,aAAqB,iBAAmBA,EAAU,cAAc,GAC1EO,EAAmBP,EAAU,cAAc,EAC3CQ,EAAeH,EAAU,EAAIE,EAAiB,OAAS,EACvDD,EAAQC,EAAiBC,CAAY,GAC3BP,EACVK,EAAQN,EAERM,EAAQD,EAAUL,EAAU,kBAAmCA,EAAU,iBAG1E,IAAIS,EAIJ,KAAOH,GAAO,CACb,MAAMI,EAAyCJ,EAE/C,GAAI,CAACf,EAAgBmB,CAAa,EAAG,CAKpC,GAJIjB,EAAqBa,CAAK,IAC7BA,EAAQ,MAAMA,EAAM,oBAAoB,GAGrC,CAACA,GAASf,EAAgBe,CAAK,EAClC,OAAO,KAGR,GAAIA,EAAM,WAAa,GAAKF,EAAgBE,CAAK,GAAK,CAACX,EAAYW,CAAK,EAAG,CAQ1E,GAPId,EAAmBc,CAAK,IAI5BG,EAAsB,MAAMP,EAAqBI,EAAOD,CAAO,EAG3D,CAACX,EAAS,GAAK,CAACe,GAAuBZ,EAAaS,CAAK,GAC5D,OAAQA,GAAS,OAAOA,EAAM,OAAU,WAAcA,EAAQ,KAG/D,GAAIG,EACH,OAAQA,GAAuB,OAAOA,EAAoB,OAAU,WAAcA,EAAsB,IAE1G,CACD,CAEAH,EAAQD,EAAUK,EAAc,YAA6BA,EAAc,gBAKvEH,GAAoB,CAACA,EAAiBC,CAAY,EAAE,SAASF,CAAK,IACrEE,EAAeH,EAAUG,EAAe,EAAIA,EAAe,EAE3DF,EAAQC,EAAiBC,CAAY,EAEvC,CAIA,OAAO,IACR,EAEA,OACCT,KAAA,yBACAI,KAAA",
  "names": ["isElementHidden", "isElementClickable", "instanceOfUI5Element", "isSafari", "isFocusTrap", "el", "isScrollable", "computedStyle", "getFirstFocusableElement", "container", "startFromContainer", "findFocusableElement", "getLastFocusableElement", "isElemFocusable", "forward", "child", "assignedElements", "currentIndex", "focusableDescendant", "originalChild"]
}
